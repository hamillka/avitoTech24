# Тестовое задание Avito

Сервис баннеров

## Содержание

1. [Описание задания](#описание-задания)
2. [Запуск сервиса](#запуск-сервиса)
3. [Детали реализации](#детали-реализации)
4. [Вопросы по заданию, возникшие во время разработки](#вопросы-по-заданию-возникшие-во-время-разработки)
5. [Таблица прогресса](#таблица-прогресса)
6. [Дальнейшее развитие](#дальнейшее-развитие)


## Описание задания

### Проблема

В Авито есть большое количество неоднородного контента, для которого необходимо иметь единую систему управления. В
частности, необходимо показывать разный контент пользователям в зависимости от их принадлежности к какой-либо группе.
Данный контент мы будем предоставлять с помощью баннеров.

### Задача

Необходимо реализовать сервис, который позволяет показывать пользователям баннеры, в зависимости от требуемой фичи и
тега пользователя, а также управлять баннерами и связанными с ними тегами и фичами.

### Общие вводные

**Баннер** — это документ, описывающий какой-либо элемент пользовательского интерфейса. Технически баннер представляет
собой JSON-документ неопределенной структуры.
**Тег** — это сущность для обозначения группы пользователей; представляет собой число (ID тега).
**Фича** — это домен или функциональность; представляет собой число (ID фичи).

1. Один баннер может быть связан только с одной фичей и несколькими тегами
2. При этом один тег, как и одна фича, могут принадлежать разным баннерам одновременно
3. Фича и тег однозначно определяют баннер

Так как баннеры являются для пользователя вспомогательным функционалом, допускается, если пользователь в течение
короткого срока будет получать устаревшую информацию. При этом существует часть пользователей (порядка 10%), которым
обязательно получать самую актуальную информацию. Для таких пользователей нужно предусмотреть механизм получения
информации напрямую из БД.

## Запуск сервиса

Сначала необходимо склонировать репозиторий и перейти в директорию:

```bash
git clone https://github.com/hamillka/avitoTech24.git
cd avitoTech24
```

Для деплоя реализован [docker-файл](./Dockerfile) и использован [docker-compose](./docker-compose.yml). Вместе с
сервисом поднимается БД в отдельном контейнере. Для этого нужно выполнить следующую команду:

```bash
docker-compose up
```

Для удобства написан [make-файл](./Makefile). С помощью команды `make run` можно запустить базу данных и приложение.
Сервис будет запущен на localhost с портом 8080.

Поскольку работа с приложением требует авторизации, то для удобства тестрования мной были созданы JWT-токены.

Для пользователя:

```
Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3Mjc4NTE5NzIsInJvbGUiOjF9.cZQq1MmrSo5yEPkv7_cGwCWnGLYwuWFKOSGNBlc_FK0
```

Для админа:

```
Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3Mjc4NTE5NzIsInJvbGUiOjB9.2My2wlmg6qvCFI-87nRahcPNr7H11vYpI5asyP8Qfwc
```

## Детали реализации

- Стек: Golang, PostgreSQL, Docker
- При разработке был использован [API](./api.yaml).
- В директории [test](./test) расположен [файл](./test/e2e_test.go), в котором реализованы E2E-тесты для сценариев
  создания, получения, обновления и удаления баннера. Выполнить тесты можно с помощью команды `make test`.
- Реализована поддержка Swagger, которая упрощает работу с API. Маршрут для
  Swagger: http://localhost:8080/swagger/

### БД

На рисунке ниже представлена схема реализованной мной базы данных `banner-service`.

![](./img/banner_service_db.png "Схема базы данных")

Таблица `bt` - связующая таблица многие-ко-многим для таблиц `banners` и `tags`. При удалении записи в `banners`
или `tags` также происходит удаление соответствующих записей в `bt`.

### Архитектура

На следующем рисунке продемонстрирована архитектура сервиса:

![](./img/banner_service_arch.png "Архитектура сервиса")

Входящий запрос обрабатывается роутером, вызывает соответствующий метод хендлера.
В каждом методе хендлере вызывается необходимый метод сервиса бизнес-логики, а в методах сервиса
вызываются методы репозиториев уровня доступа к данным.

### Линтер

В [файле](./golangci.yaml) описана конфигурация линтера, которая следит за качеством кода и помогает исправлять
логические и стилистические ошибки во время разработки.

## Вопросы по заданию, возникшие во время разработки

- В API для GET /banner не описан статус-код для случая, когда баннер не был найден. При разработке было принято
  решение использовать StatusNotFound (404) при возникновении такой ситуации
- Для ситуации, когда пользователь передает флаг use_last_revision, было принято решение использовать СУБД Redis
  для реализации кэширования с целью возвращать информацию, которая была актуальна 5 минут назад. Из-за нехватки времени
  реализовать данный пункт я не успел.

## Таблица прогресса

| Задача                                               | Прогресс | Комментарий                                                                                                                                  |
|------------------------------------------------------|:--------:|----------------------------------------------------------------------------------------------------------------------------------------------|
| **Метод получения баннеря для пользователя**         |    ✅     |                                                                                                                                              |
| **Метод получения всех баннеров по фиче и/или тегу** |    ✅     |                                                                                                                                              |
| **Метод создания баннера**                           |    ✅     |                                                                                                                                              |
| **Метод обновления содержимого баннера**             |    ✅     |                                                                                                                                              |
| **Метод удаления баннера по идентификатору**         |    ✅     |                                                                                                                                              |
| **Авторизация**                                      |    ✅     | Был реализован middleware, который проверяет JWT-токен, переданный в Header\'е с именем `auth-x`, и разрешает или запрещает действие клиенту |
| **E2E-тесты**                                        |    ✅     | Были созданы E2E-тесты для проверки получения баннера                                                                                        |
| **Запуск в docker**                                  |    ✅     |                                                                                                                                              |
| **Флаг use_last_revision**                           |    ❌     | Не успел привязать Redis для кэширования баннеров                                                                                            |
| **Дополнительные тесты**                             |    ✅     | Были реализованы E2E-тесты для создания, изменения и удаления баннеров                                                                       |
| **Версионирование**                                  |    ❌     | Идея: создать дополнительную таблицу с историей                                                                                              |
| **Нагрузочное тестирование**                         |    ❌     |                                                                                                                                              |
| **Линтер**                                           |    ✅     | Описана конфигурация линтера                                                                                                                 |
| **Swagger**                                          |    ✅     |                                                                                                                                              |
| **CI/CD**                                            |    ✅     |                                                                                                                                              |

## Дальнейшее развитие

- Реализовать работу с флагом use_last_revision
- Выполнить нагрузочное тестирование и изучить малоэффективные части кода для повышения производительности
- Реализовать сохранение истории изменения баннеров для возможности выполнить "откат" до предыдущих версий
